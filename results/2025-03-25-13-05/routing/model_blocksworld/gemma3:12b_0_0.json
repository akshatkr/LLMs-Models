{
    "move_to_node": {
        "predicate_prompt": "You can create and define new predicates, but you may also reuse the following predicates:\nNo predicate has been defined yet",
        "action_desc": "The robot moves to the specified node in the network, provided there is an edge connecting the current node to the target node. The robot can only move along edges that are part of the network. The robot must be at a valid node to begin moving.",
        "iter_1": {
            "llm_output": "Okay, here's the PDDL representation of the \"move to node\" action, based on the provided domain information. I'm focusing on capturing the core constraints and effects.\n\n```pddl\nAction: move-to-node\n\nParameters:\n1. ?current_node - node: The node the robot is currently at.\n2. ?next_node - node: The node the robot is moving to.\n\nPreconditions:\n```\n(and\n   (connected ?current_node ?next_node)\n   (network-contains ?current_node)\n   (network-contains ?next_node)\n   (not (visited ?next_node))\n   (robot-at ?current_node)\n)\n```\n\nEffects:\n```\n(and\n   (not (robot-at ?current_node))\n   (robot-at ?next_node)\n   (visited ?next_node)\n)\n```\n\nNew Predicates:\n1. (connected ?node1 - node ?node2 - node): true if there is an edge connecting node ?node1 to node ?node2.\n2. (network-contains ?node - node): true if the network contains the node ?node.\n3. (robot-at ?node - node): true if the robot is currently at the node ?node.\n4. (visited ?node - node): true if the node ?node has been visited in the current route.\n```\n\n**Explanation and Reasoning:**\n\n*   **`connected ?current_node ?next_node`**: This is a fundamental precondition. The robot can only move if there's a direct connection (edge) between the current node and the target node.\n*   **`network-contains ?current_node` and `network-contains ?next_node`**:  Ensures that both the current and next nodes are part of the network.  This prevents the robot from trying to move to nodes outside the defined network.\n*   **`not (visited ?next_node)`**: This is crucial for the \"visit each node exactly once\" constraint. The robot can only move to a node if it hasn't already been visited in the current route.\n*   **`robot-at ?current_node`**: The robot must be at the current node to begin moving.\n*   **`not (robot-at ?current_node)`**: The robot is no longer at the current node after the move.\n*   **`robot-at ?next_node`**: The robot is now at the target node.\n*   **`visited ?next_node`**:  The target node is marked as visited.\n\n**Important Considerations and Potential Extensions:**\n\n*   **Route Completion:**  The problem description mentions completing the route.  This would likely require an additional predicate (e.g., `route-complete`) and a condition in the effects of a separate \"route-complete\" action.\n*   **Starting Node:**  You'd likely need a predicate to specify the robot's initial location (e.g., `initial-robot-location ?node`).\n*   **Edge Direction:** If edges are directed (one-way), the `connected` predicate would need to reflect that directionality.\n*   **Error Handling:**  You might want to add predicates and actions to handle situations where a valid move isn't possible (e.g., a \"dead end\").\n*   **Path Planning:** This action only handles a single move. A more complex system might involve a path planning action that determines a sequence of moves to reach a goal.\n"
        },
        "llm_output": "Okay, here's the PDDL representation of the \"move to node\" action, based on the provided domain information. I'm focusing on capturing the core constraints and effects.\n\n```pddl\nAction: move-to-node\n\nParameters:\n1. ?current_node - node: The node the robot is currently at.\n2. ?next_node - node: The node the robot is moving to.\n\nPreconditions:\n```\n(and\n   (connected ?current_node ?next_node)\n   (network-contains ?current_node)\n   (network-contains ?next_node)\n   (not (visited ?next_node))\n   (robot-at ?current_node)\n)\n```\n\nEffects:\n```\n(and\n   (not (robot-at ?current_node))\n   (robot-at ?next_node)\n   (visited ?next_node)\n)\n```\n\nNew Predicates:\n1. (connected ?node1 - node ?node2 - node): true if there is an edge connecting node ?node1 to node ?node2.\n2. (network-contains ?node - node): true if the network contains the node ?node.\n3. (robot-at ?node - node): true if the robot is currently at the node ?node.\n4. (visited ?node - node): true if the node ?node has been visited in the current route.\n```\n\n**Explanation and Reasoning:**\n\n*   **`connected ?current_node ?next_node`**: This is a fundamental precondition. The robot can only move if there's a direct connection (edge) between the current node and the target node.\n*   **`network-contains ?current_node` and `network-contains ?next_node`**:  Ensures that both the current and next nodes are part of the network.  This prevents the robot from trying to move to nodes outside the defined network.\n*   **`not (visited ?next_node)`**: This is crucial for the \"visit each node exactly once\" constraint. The robot can only move to a node if it hasn't already been visited in the current route.\n*   **`robot-at ?current_node`**: The robot must be at the current node to begin moving.\n*   **`not (robot-at ?current_node)`**: The robot is no longer at the current node after the move.\n*   **`robot-at ?next_node`**: The robot is now at the target node.\n*   **`visited ?next_node`**:  The target node is marked as visited.\n\n**Important Considerations and Potential Extensions:**\n\n*   **Route Completion:**  The problem description mentions completing the route.  This would likely require an additional predicate (e.g., `route-complete`) and a condition in the effects of a separate \"route-complete\" action.\n*   **Starting Node:**  You'd likely need a predicate to specify the robot's initial location (e.g., `initial-robot-location ?node`).\n*   **Edge Direction:** If edges are directed (one-way), the `connected` predicate would need to reflect that directionality.\n*   **Error Handling:**  You might want to add predicates and actions to handle situations where a valid move isn't possible (e.g., a \"dead end\").\n*   **Path Planning:** This action only handles a single move. A more complex system might involve a path planning action that determines a sequence of moves to reach a goal.\n",
        "new_predicates": [
            "(connected ?node1 - node ?node2 - node): true if there is an edge connecting node ?node1 to node ?node2.",
            "(network-contains ?node - node): true if the network contains the node ?node.",
            "(robot-at ?node - node): true if the robot is currently at the node ?node.",
            "(visited ?node - node): true if the node ?node has been visited in the current route."
        ]
    },
    "visit_node": {
        "predicate_prompt": "You can create and define new predicates, but you may also reuse the following predicates:\n1. (connected ?node1 - node ?node2 - node): true if there is an edge connecting node ?node1 to node ?node2.\n2. (network-contains ?node - node): true if the network contains the node ?node.\n3. (robot-at ?node - node): true if the robot is currently at the node ?node.\n4. (visited ?node - node): true if the node ?node has been visited in the current route.",
        "action_desc": "The robot visits the node, marking it as visited in the route. The robot can only visit each node once. This action cannot be performed if the node has already been visited. Visiting a node is necessary to complete the route.",
        "iter_1": {
            "llm_output": "```\n(and\n    (network-contains ?node)\n    (robot-at ?node)\n    (not (visited ?node))\n)\n```\n\nEffects:\n```\n(and\n   (visited ?node)\n)\n```\n\nNew Predicates:\nNo newly defined predicate\n```"
        },
        "llm_output": "```\n(and\n    (network-contains ?node)\n    (robot-at ?node)\n    (not (visited ?node))\n)\n```\n\nEffects:\n```\n(and\n   (visited ?node)\n)\n```\n\nNew Predicates:\nNo newly defined predicate\n```",
        "new_predicates": []
    },
    "unvisit_node": {
        "predicate_prompt": "You can create and define new predicates, but you may also reuse the following predicates:\n1. (connected ?node1 - node ?node2 - node): true if there is an edge connecting node ?node1 to node ?node2.\n2. (network-contains ?node - node): true if the network contains the node ?node.\n3. (robot-at ?node - node): true if the robot is currently at the node ?node.\n4. (visited ?node - node): true if the node ?node has been visited in the current route.",
        "action_desc": "The robot unmarks the node as visited, making it available to be visited again if needed. This action may be used during certain search strategies. The node must have previously been visited to unvisit it. Unvisiting nodes is typically part of a backtracking or exploration strategy.",
        "iter_1": {
            "llm_output": "```\n(and\n   (visited ?node - node)\n)\n```\n\nEffects:\n```\n(and\n   (not (visited ?node - node))\n)\n```\n\nNew Predicates:\nNo newly defined predicate\n```"
        },
        "llm_output": "```\n(and\n   (visited ?node - node)\n)\n```\n\nEffects:\n```\n(and\n   (not (visited ?node - node))\n)\n```\n\nNew Predicates:\nNo newly defined predicate\n```",
        "new_predicates": []
    },
    "check_edge": {
        "predicate_prompt": "You can create and define new predicates, but you may also reuse the following predicates:\n1. (connected ?node1 - node ?node2 - node): true if there is an edge connecting node ?node1 to node ?node2.\n2. (network-contains ?node - node): true if the network contains the node ?node.\n3. (robot-at ?node - node): true if the robot is currently at the node ?node.\n4. (visited ?node - node): true if the node ?node has been visited in the current route.",
        "action_desc": "The robot checks if there is an edge connecting the current node to a specific target node in the network. The robot can use this action to explore possible paths before making a move. This action does not change the state of the nodes.",
        "iter_1": {
            "llm_output": "```\n(and\n   (network-contains ?current-node - node)\n   (network-contains ?target-node - node)\n   (connected ?current-node - node ?target-node - node)\n)\n```\n\nEffects:\n```\n(and\n   (edge-checked ?current-node - node ?target-node - node)\n)\n```\n\nNew Predicates:\n1. (edge-checked ?node1 - node ?node2 - node): true if the robot has checked if there is an edge connecting node ?node1 to node ?node2.\n```"
        },
        "llm_output": "```\n(and\n   (network-contains ?current-node - node)\n   (network-contains ?target-node - node)\n   (connected ?current-node - node ?target-node - node)\n)\n```\n\nEffects:\n```\n(and\n   (edge-checked ?current-node - node ?target-node - node)\n)\n```\n\nNew Predicates:\n1. (edge-checked ?node1 - node ?node2 - node): true if the robot has checked if there is an edge connecting node ?node1 to node ?node2.\n```",
        "new_predicates": [
            "(edge-checked ?node1 - node ?node2 - node): true if the robot has checked if there is an edge connecting node ?node1 to node ?node2."
        ]
    },
    "end_route": {
        "predicate_prompt": "You can create and define new predicates, but you may also reuse the following predicates:\n1. (connected ?node1 - node ?node2 - node): true if there is an edge connecting node ?node1 to node ?node2.\n2. (network-contains ?node - node): true if the network contains the node ?node.\n3. (robot-at ?node - node): true if the robot is currently at the node ?node.\n4. (visited ?node - node): true if the node ?node has been visited in the current route.\n5. (edge-checked ?node1 - node ?node2 - node): true if the robot has checked if there is an edge connecting node ?node1 to node ?node2.",
        "action_desc": "The robot completes its route by reaching the last node in the path, ensuring that all nodes have been visited exactly once. The robot must have visited all nodes before performing this action. This action signifies the completion of the route.",
        "iter_1": {
            "llm_output": "```pddl\nAction: complete-route\n\nParameters:\n1. ?last-node - node: The last node in the route.\n\nPreconditions:\n```\n(and\n  (forall (?node - node) (implies (network-contains ?node) (visited ?node)))\n  (forall (?node1 - node ?node2 - node) (imply (edge-checked ?node1 ?node2) (not (connected ?node1 ?node2))))\n  (robot-at ?last-node)\n)\n```\n\nEffects:\n```\n(and\n  (not (robot-at ?last-node))\n  (route-complete)\n)\n```\n\nNew Predicates:\n1. (route-complete): true if the robot has completed the route.\n```"
        },
        "llm_output": "```pddl\nAction: complete-route\n\nParameters:\n1. ?last-node - node: The last node in the route.\n\nPreconditions:\n```\n(and\n  (forall (?node - node) (implies (network-contains ?node) (visited ?node)))\n  (forall (?node1 - node ?node2 - node) (imply (edge-checked ?node1 ?node2) (not (connected ?node1 ?node2))))\n  (robot-at ?last-node)\n)\n```\n\nEffects:\n```\n(and\n  (not (robot-at ?last-node))\n  (route-complete)\n)\n```\n\nNew Predicates:\n1. (route-complete): true if the robot has completed the route.\n```",
        "new_predicates": [
            "(route-complete): true if the robot has completed the route."
        ]
    }
}